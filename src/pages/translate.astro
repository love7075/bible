---
// import Version from "../components/version.astro";
// import Book from "../components/books.astro";
import "../styles/global.css";
import Layout from "../layouts/Layout.astro";
export const prerender = true;
---

<Layout title="平行阅读">
    <div class="flex space-x-2">
        <a href="/" class="mr-4">首页</a>
        <label>版本:</label><select id="version1" class="mr-4"></select>
        <label>书卷:</label><select id="books" class="mr-4"></select>
        <label>章节:</label><select id="chapters" class="w-16 mr-4"></select>
        <label>版本:</label><select id="version2" class="mr-4"></select>
        <button class="prepage">上一章</button>
        <button class="nextpage">下一章</button>
    </div>
    <div class="flex p-2">
        <div id="content1" class="flex-1"></div>
        <div id="content2" class="flex-1"></div>
    </div>
    <div class="flex justify-center gap-4">
        <button class="prepage">上一章</button>
        <button class="nextpage">下一章</button>
    </div>
    <div id="message" class="fixed top-4 right-4 p-4 rounded shadow-lg hidden">
    </div>
</Layout>

<script>
    import {
        versionInfo,
        bookMap,
        getNextpage,
        getPrepage,
    } from "../lib/bibledata";
    import { fillSelectNumber, fillSelectArray } from "../lib/utils";
    import { api } from "../lib/api";

    const version1 = document.getElementById("version1") as HTMLSelectElement;
    const version2 = document.getElementById("version2") as HTMLSelectElement;

    const selectChapters = document.getElementById(
        "chapters",
    ) as HTMLSelectElement;
    const selectBooks = document.getElementById("books") as HTMLSelectElement;
    const bookList: [string, string][] = bookMap.map((item) => [
        item.key,
        item.name,
    ]);
    fillSelectArray(version1, Object.entries(versionInfo));
    fillSelectArray(version2, Object.entries(versionInfo));
    fillSelectArray(selectBooks, bookList);

    // versions.forEach((v) => ((v as HTMLSelectElement).selectedIndex = 0));

    //内容布局
    const content1 = document.getElementById("content1");
    const content2 = document.getElementById("content2");

    // 缓存已加载的 chunk 数据
    const chunkCache = new Map<string, any>();

    async function loadChunkData(chunkUrl: string): Promise<any> {
        // 如果缓存中已有数据，直接返回
        if (chunkCache.has(chunkUrl)) {
            return chunkCache.get(chunkUrl);
        }

        // 否则从网络加载
        const response = await fetch(chunkUrl);
        const chunkData = await response.json();

        // 存入缓存
        chunkCache.set(chunkUrl, chunkData);
        return chunkData;
    }
    function showMessage(text: string, type: "success" | "error") {
        const message = document.getElementById("message");
        if (message) {
            message.textContent = text;
            message.className = `fixed top-4 right-4 p-4 rounded shadow-lg ${
                type === "success" ? "bg-green-500" : "bg-red-500"
            } text-white`;
            message.classList.remove("hidden");
            setTimeout(() => {
                message.classList.add("hidden");
            }, 3000);
        }
    }
    // 新函数：设置可编辑经文的事件和按钮
    function setupEditableVerse(span: HTMLElement, verse: any) {
        // 初始状态设置为不可编辑
        (span as HTMLElement).contentEditable = "false";

        // 添加点击事件
        span.addEventListener("click", (e) => {
            // 检查登录状态
            if (!localStorage.getItem("token")) {
                showMessage("请先登录后再编辑", "error");
                return;
            }

            // 将所有其他经文设置为不可编辑
            document.querySelectorAll(".editable").forEach((el) => {
                (el as HTMLElement).contentEditable = "false";
                // 移除其他经文的确认和取消按钮
                const nextBtn = el.nextElementSibling;
                if (
                    nextBtn?.classList.contains("confirm-btn") ||
                    nextBtn?.classList.contains("cancel-btn")
                ) {
                    nextBtn.remove();
                }
                const nextNextBtn = nextBtn?.nextElementSibling;
                if (
                    nextNextBtn?.classList.contains("confirm-btn") ||
                    nextNextBtn?.classList.contains("cancel-btn")
                ) {
                    nextNextBtn.remove();
                }
            });

            // 移除当前经文可能存在的按钮
            const target = e.target as HTMLElement;
            const nextBtn = target.nextElementSibling;
            if (
                nextBtn?.classList.contains("confirm-btn") ||
                nextBtn?.classList.contains("cancel-btn")
            ) {
                nextBtn.remove();
            }
            const nextNextBtn = nextBtn?.nextElementSibling;
            if (
                nextNextBtn?.classList.contains("confirm-btn") ||
                nextNextBtn?.classList.contains("cancel-btn")
            ) {
                nextNextBtn.remove();
            }

            // 设置当前点击的经文为可编辑
            target.contentEditable = "true";
            target.focus();

            // 先移除可能存在的失去焦点事件监听器
            const oldBlurHandler = target.onblur;
            target.onblur = null;

            // 添加确认按钮
            const confirmBtn = document.createElement("button");
            confirmBtn.className =
                "confirm-btn ml-2 px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600";
            confirmBtn.textContent = "确认";
            console.log("创建确认按钮");

            const handleConfirm = async (e: MouseEvent) => {
                console.log("确认按钮被点击");
                e.preventDefault(); // 阻止默认行为
                e.stopPropagation(); // 阻止事件冒泡
                const verseId = target.dataset.verseId;
                const newText = target.textContent;
                console.log("准备更新:", { verseId, newText });

                if (verseId && newText) {
                    try {
                        console.log("发送更新请求:", {
                            version: version1.value,
                            refId: verseId,
                            content: newText,
                        });

                        const response = await api.post("/api/verses/update", {
                            version: version1.value,
                            refId: verseId,
                            content: newText,
                        });

                        const responseData = await response.json();
                        console.log("API响应:", responseData);

                        if (!response.ok) {
                            throw new Error(responseData.error || "更新失败");
                        }

                        // 更新成功后，先移除失去焦点事件
                        target.onblur = null;

                        // 更新经文内容
                        verse.content = newText;

                        showMessage("更新成功", "success");
                        confirmBtn.remove(); // 移除确认按钮
                        cancelBtn.remove(); // 移除取消按钮
                        target.contentEditable = "false"; // 保存后设置为不可编辑

                        // 恢复原来的失去焦点事件
                        target.onblur = oldBlurHandler;
                    } catch (error) {
                        console.error("更新失败:", error);
                        showMessage(
                            "更新失败：" +
                                (error instanceof Error
                                    ? error.message
                                    : "未知错误"),
                            "error",
                        );
                        target.textContent = verse.content; // 恢复原文本
                        confirmBtn.remove(); // 移除确认按钮
                        cancelBtn.remove(); // 移除取消按钮
                        target.contentEditable = "false"; // 失败后设置为不可编辑
                        target.onblur = oldBlurHandler; // 恢复原来的失去焦点事件
                    }
                }
            };

            confirmBtn.onmousedown = handleConfirm;
            console.log("确认按钮事件已绑定");

            // 添加取消按钮
            const cancelBtn = document.createElement("button");
            cancelBtn.className =
                "cancel-btn ml-2 px-2 py-1 bg-gray-500 text-white rounded hover:bg-gray-600";
            cancelBtn.textContent = "取消";
            console.log("创建取消按钮");

            const handleCancel = (e: MouseEvent) => {
                console.log("取消按钮被点击");
                e.preventDefault(); // 阻止默认行为
                e.stopPropagation(); // 阻止事件冒泡
                // 先移除失去焦点事件
                target.onblur = null;
                target.textContent = verse.content; // 恢复原文本
                confirmBtn.remove(); // 移除确认按钮
                cancelBtn.remove(); // 移除取消按钮
                target.contentEditable = "false"; // 设置为不可编辑
                // 恢复原来的失去焦点事件
                target.onblur = oldBlurHandler;
            };

            cancelBtn.onmousedown = handleCancel;
            console.log("取消按钮事件已绑定");

            // 添加新的失去焦点事件
            target.onblur = () => {
                console.log("经文失去焦点");
                // 检查是否点击了确认或取消按钮
                const activeElement = document.activeElement;
                if (
                    activeElement !== confirmBtn &&
                    activeElement !== cancelBtn
                ) {
                    confirmBtn.remove(); // 移除确认按钮
                    cancelBtn.remove(); // 移除取消按钮
                    target.contentEditable = "false"; // 设置为不可编辑
                    target.textContent = verse.content; // 恢复原文本
                    target.onblur = oldBlurHandler; // 恢复原来的失去焦点事件
                }
            };

            target.parentNode?.insertBefore(confirmBtn, target.nextSibling);
            target.parentNode?.insertBefore(cancelBtn, confirmBtn.nextSibling);
            console.log("按钮已添加到DOM");
        });
    }

    // 新函数：获取经文数据
    async function fetchVerseData(
        version: string,
        book: string,
        chapter: number,
        url: string,
    ): Promise<any[]> {
        if (version === "zyb") {
            // 对于zyb版本，使用API获取数据
            const response = await fetch(
                `/api/verses/get?version=${version}&book=${book}&chapter=${chapter}`,
            );
            return await response.json();
        } else {
            // 对于其他版本，使用chunk数据
            const chunkData = await loadChunkData(url);
            // 在数组中查找当前书卷和章节的经文
            const chapterData = chunkData.find(
                (item: { book: string; chapter: number }) =>
                    item.book === book && item.chapter === chapter,
            );
            return chapterData?.verses || [];
        }
    }

    // 新函数：渲染单个经文
    function renderVerse(
        verse: any,
        content: HTMLElement,
        isZybVersion: boolean,
    ) {
        const p = document.createElement("p");
        if (isZybVersion) {
            const refId = verse.refId;
            const verseText = verse.content; // zyb版本使用verse.content作为可编辑内容
            p.innerHTML = `${verse.verse} <span class="editable" data-verse-id="${refId}">${verseText}</span>`;
            const span = p.querySelector(".editable");
            if (span) {
                setupEditableVerse(span as HTMLElement, verse);
            }
        } else {
            p.innerHTML = `${verse.num} ${verse.verse}`; // 其他版本使用verse.num和verse.verse
        }
        content.appendChild(p);
    }

    // 重构后的 fetchJson 函数
    async function fetchJson(url: string, content: HTMLElement): Promise<void> {
        content.innerHTML = "";
        try {
            const currentVersion =
                content === content1 ? version1.value : version2.value;
            const isZybVersion = currentVersion === "zyb";
            const data = await fetchVerseData(
                currentVersion,
                selectBooks.value,
                parseInt(selectChapters.value),
                url,
            );

            for (const verse of data) {
                renderVerse(verse, content, isZybVersion);
            }
        } catch (error) {
            console.error("获取数据时出错:", error);
        }
    }

    function syncRowHeights() {
        const rows1 = document.querySelectorAll("#content1 p");
        const rows2 = document.querySelectorAll("#content2 p");

        // console.log("rows1", rows1);
        const len = Math.min(rows1.length, rows2.length);

        for (let i = 0; i < len; i++) {
            // 先清除之前设置的高度
            (rows1[i] as HTMLElement).style.height = "";
            (rows2[i] as HTMLElement).style.height = "";

            const h1 = (rows1[i] as HTMLElement).offsetHeight;
            const h2 = (rows2[i] as HTMLElement).offsetHeight;
            const maxHeight = Math.max(h1, h2);

            (rows1[i] as HTMLElement).style.height = maxHeight + "px";
            (rows2[i] as HTMLElement).style.height = maxHeight + "px";
        }
    }
    async function loadAndSync() {
        if (content1 && content2) {
            const currentBook = bookMap.find(
                (book) => book.key === selectBooks.value,
            );
            if (!currentBook) return;

            const chunk = currentBook.chunk || 1; // 默认使用1作为chunk值
            const chapterNum = parseInt(selectChapters.value);
            const url1 = `/version/${version1.value}/chunk${chunk}.json`;
            const url2 = `/version/${version2.value}/chunk${chunk}.json`;

            await fetchJson(url1, content1);
            await fetchJson(url2, content2);
            syncRowHeights();
        }
    }
    function bookChanged() {
        fillSelectNumber(
            selectChapters,
            bookMap.find((v) => v.key === selectBooks.value)?.chapters ?? 0,
        );
        selectChapters.selectedIndex = 0;
    }
    version1.selectedIndex = 0;
    version2.selectedIndex = 1;
    selectBooks.selectedIndex = 0;
    bookChanged(); // 确保章节下拉菜单在加载时被正确填充
    selectChapters.selectedIndex = 0;
    version1.addEventListener("change", () => loadAndSync());
    version2.addEventListener("change", () => loadAndSync());
    selectChapters.addEventListener("change", () => loadAndSync());
    selectBooks.addEventListener("change", () => bookChanged());
    // version1.dispatchEvent(new Event("change", { bubbles: true }));
    // selectBooks.dispatchEvent(new Event("change", { bubbles: true }));
    // selectChapters.dispatchEvent(new Event("change", { bubbles: true }));

    window.addEventListener("DOMContentLoaded", loadAndSync);

    document.querySelectorAll(".nextpage").forEach((b) => {
        console.log("add events");
        b.addEventListener("click", () => {
            // console.log("button click");
            let exist_next = false;
            if (
                selectChapters.selectedIndex <
                selectChapters.options.length - 1
            ) {
                selectChapters.selectedIndex = selectChapters.selectedIndex + 1;
                exist_next = true;
            } else if (
                selectBooks.selectedIndex <
                selectBooks.options.length - 1
            ) {
                selectChapters.selectedIndex = 0;

                selectBooks.selectedIndex = selectBooks.selectedIndex + 1;
                exist_next = true;
            }
            if (exist_next) {
                loadAndSync();
                window.scrollTo(0, 0);
            }
        });
    });
    document.querySelectorAll(".prepage").forEach((b) => {
        console.log("add events");
        b.addEventListener("click", () => {
            // console.log("button click");
            let exist_next = false;
            if (selectChapters.selectedIndex > 0) {
                selectChapters.selectedIndex = selectChapters.selectedIndex - 1;
                exist_next = true;
            } else if (selectBooks.selectedIndex > 0) {
                selectBooks.selectedIndex = selectBooks.selectedIndex - 1;
                bookChanged();
                selectChapters.selectedIndex =
                    selectChapters.options.length - 1;

                exist_next = true;
            }
            if (exist_next) {
                window.scrollTo(0, 0);
                loadAndSync();
            }
        });
    });
</script>
